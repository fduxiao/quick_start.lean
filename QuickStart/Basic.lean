/-!
In this file, we have basically two things: formal lean codes and comments. Lean codes are just
what they are called and comments are lines of natural language encompassed in /- -/ (we may have
some variants like --, /-! -/ and /-- -/).

Though to write a lean program only requires those lean codes, sometimes it is helpful to explain
them in natural language. In fact, I write this file treating it as a book, where most lines are
comments with relatively less lean codes.

Besides, `/-! -/` is used for Markdown display, i.e., we can have headers(#), citations(>), etc.
And `/-- -/` is used for DocString (you will figure it out later by hover the cursor on some term).

# Basic types and functional programming

## Introduction
The core of modern computer proof assistants is always λ-calculus, i.e. functional programming.
This chapter is intended to introduce some basics about functional programming in lean.
In modern (dependent) type theory, we give a lot of *rules* to define the judgement `term: type`.
Functions are just a special rule to form a certain type, and proofs are just the judgement
`proof: proposition`, as is the Curry-Howard correspondence. I am going to introduce you those
*rules* in lean.

Programming languages based on λ-calculus have only a few core features (axioms in meta language).
And all you need for logic can be built from scratch within these features.
-/


/-!

## Days of a week
Our first example is to define a `finite` type. Just like defining a finite set, you can define
a type by enumerating all possible members.

The keyword to define a type is `inductive`. (You can tell why it is called `inductive` if you have
learned some type theory; otherwise, just accept that as a name.)

The following says we are going to define a new type `Week` in the universe `Type` with judgements
`Sunday: Week`, `Monday: Week`, etc. Recall that this definition means the judgement `term: Week`
is freely generated by the *constructors* `Sunday: Week, Monday: Week, ...`.
-/

inductive Week: Type :=
  | Sunday: Week
  | Monday: Week
  | Tuesday: Week
  | Wednesday  -- the `: Week` can be omitted since it can be infered from the context
  | Thrusday
  | Friday | Saturday -- you can write these constructors in one line
  deriving Repr -- This line is only for some technical reason, indicating you can display Week by its constructors


/-!
We are then able to check the newly defined type by

```lean
#check Week.Sunday
```
-/

#check Week.Sunday -- this will not be shown in doc-gen.

/-!
## Namespaces

You may have noticed that we have actually defined `Week.Sunday: Week`. To access the term `Sunday`,
we have to write `Week.Sunday`. This `Week` acts as a `namespace` so that if we have another type
with the same constructor names, we won't fall into a name conflict.
-/
inductive Weekend: Type := | Sunday | Saturday

#check Week.Sunday

/-!
If you want to use those names in a namespace directly, you can `open` it

```lean
open Weekend
#check Sunday
```
-/

open Weekend
#check Sunday

/-!
Namespaces can also be defined manually. This is helpful if you want to define something with existing
names. For example, lean has provided the type `Bool` with constructors `true` and `false`. To show you
how to define it from scratch, I have to define my own `Bool` using a different name `MyBool`, or I can
use a `namespace` to avoid it.
-/

inductive MyBool := | true | false

namespace scratch

  inductive Bool := | true | false
  open Bool

end scratch


/-!
Another application is to define the classical logic. As you know, Curry-Howard correspondence
is only true for intuitionistic logic. But you may want to use *law of excluded middle* since we have
the double negation monad (Glivenko's theorem) embedding classical logic in intuitionistic logc. We can
put those classical axioms in a namespace to use them if necessary. (Lean also provides such a namespace
called `Classical`)
-/
namespace classical

axiom em: forall (p: Prop), p ∨ ¬ p

end classical

/-!
## Define functions by case analysis
Now we know how to define a type by enumerating. Then a natural way to define
a function out of those types is to define a value for each case of those types.
This is known as case analysis (proof by cases)
-/

/--
The next day in a week
-/
def next_weekday: Week -> Week := λ (w: Week) =>
  match w with
  | Week.Sunday => Week.Monday
  | Week.Monday => Week.Tuesday
  | .Tuesday => .Wednesday -- we can omit Week
  | .Wednesday => .Thrusday
  | .Thrusday => .Friday
  | .Friday => .Saturday
  | .Saturday => .Sunday


/-!
To test the function `next_weekday`, using `#eval`

```lean
#eval next_weekday Week.Sunday
```
-/

#eval (next_weekday Week.Sunday)


/-!
## Syntactic Sugar
The above might be thought as the `standard` way to define a function by lambda calculus.
However, it may not be the most convenient way to define a function. For example, the semantics
of the above `next_weekday` can be interpreted as: for every `w: Week`, we want to find
a term of type `week` for the application `next_weekday w`, i.e., the following. This *sweeter*
way to write down the same thing with a different syntax is called a **syntactic sugar**
(Note the prime `'` after the name. In lean, we are unable to change a defined name)
-/

def next_weekday' (w: Week): Week := match w with
  | Week.Sunday => Week.Monday
  | Week.Monday => Week.Tuesday
  | .Tuesday => .Wednesday -- we can omit Week
  | .Wednesday => .Thrusday
  | .Thrusday => .Friday
  | .Friday => .Saturday
  | .Saturday => .Sunday


/-!
Moreover, we have another syntax sugar for `match`.
-/
def next_weekday'': Week -> Week
  | Week.Sunday => Week.Monday
  | Week.Monday => Week.Tuesday
  | .Tuesday => .Wednesday
  | .Wednesday => .Thrusday
  | .Thrusday => .Friday
  | .Friday => .Saturday
  | .Saturday => .Sunday

/-!
This is especially useful when you are defining a curried function.
-/

namespace scratch

def and: Bool -> Bool -> Bool
  | .true, .true => .true
  | .false, .true => .false
  | _, _ => .false -- wildcard

end scratch

/-!
You can also define the `next_weekday` in the namespace `Week`. This time, let's call
it `Week.next`. But to use it, you have to spell the full name: `Week.next Week.Wednesday`.
The good part of that is you can use `w.next` for some `w: Week`.
-/

def Week.next: Week -> Week := next_weekday -- certainly you can use your own definitions
#eval Week.Wednesday.next

/-!
Now you can try the next exercise.
-/
/--
Your own doc string
-/
inductive TrafficLight: Type
